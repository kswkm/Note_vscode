#✅ fork()를 쓰는 가장 큰 이유 5가지
1️⃣ 새 프로세스를 생성하기 위해 (유일한 방법)
리눅스에서 프로세스를 만드는 대표적인 방법은 fork() + exec() 조합이다.
fork() → 부모 프로세스를 복제하여 새로운 프로세스 생성
exec() → 새 프로세스에 다른 프로그램을 로드해서 실행
📌 즉, OS에서 돌아가는 거의 모든 프로그램은
fork → exec 과정을 거쳐 생성됨.


2️⃣ 부모와 자식이 다른 일을 동시에 실행할 수 있게 하기 위해
fork() 후에는 프로세스가 두 개가 되기 때문에
각각 독립적으로 일을 할 수 있다.
예: 웹 서버(Apache, Nginx, MySQL 등)
부모: 새로운 클라이언트 접속 기다림
자식: 접속한 클라이언트 요청 처리
병렬 처리 구현에 아주 적합하다.


3️⃣ 서버에서 여러 요청을 동시에 처리하기 위해
예: 웹 서버, DB 서버, FTP 서버 등
서버는 요청이 들어올 때마다 fork()로 새로운 프로세스 생성 → 해당 요청 처리.
📌 장점: 한 클라이언트가 문제를 일으켜도 다른 프로세스에는 영향 없음
메모리 독립성 → 안정적


4️⃣ 프로세스 격리 및 안정성 확보
fork()는 부모와 메모리를 공유하지 않기 때문에
자식 프로세스가 죽어도 부모는 정상 작동.
예: 서버 한 클라이언트가 오류를 일으켜도 전체 서버 다운 X
빌드 시스템 매 작업이 독립적으로 동작
샌드박스 같은 격리 기능 구현 가능


5️⃣ 병렬 작업 수행(멀티프로세싱)
멀티코어 시스템에서 여러 CPU 코어를 실제로 활용하려면
프로세스를 여러 개 만드는 것이 더 효과적일 때도 많다.
Python 같은 언어에서도
멀티스레드 대신 멀티프로세스를 선호하는 이유가 바로 이것.


🧠 추가 보너스: fork()가 효율적인 기술적 이유
✔ Copy-on-Write(COW)
fork()는 전체 메모리를 복사하는 것처럼 보이지만…
📌 실제로는 복사하지 않음! (쓰기 전까지 공유함)
→ 그래서 포크 비용이 매우 저렴하고 빠름.


#프로세스 관리 명령어
프로세스 확인(ps, htop)
 > ps

Handles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName
-------  ------    -----      -----     ------     --  -- -----------
    139       8     1744       9804              9652   0 AggregatorHost
    391      20    13192      29140       0.81   4552   1 aihost
    499      31    35096      63308       1.00   9740   1 AIXHost
    302      16    12384      33008       1.78  16704   1 AppActions
    451      28    56388      64324       2.42  20436   1 ApplicationFrameHost

📌 1. Handles
해당 프로세스가 열고 있는 핸들의 개수
(파일, 레지스트리, 스레드, 소켓 등 OS 자원)

📌 2. NPM(K)
Non-Paged Memory
→ 디스크로 스왑될 수 없는, 반드시 RAM에 남아있어야 하는 커널 메모리
단위: KB

📌 3. PM(K)
Paged Memory
→ 페이지 파일(Pagefile)로 스왑 가능한 메모리
(프로세스가 사용 중인 가상 메모리의 일부)

📌 4. WS(K)
Working Set Memory
→ 프로세스가 실제로 RAM에서 사용 중인 메모리량
WS(Working Set)가 클수록 지금 실제로 많이 사용하는 상태.

📌 5. CPU(s)
프로세스가 실행되면서 누적해서 사용한 CPU 시간 (초)
0.81 → CPU 0.81초 사용했다는 의미

📌 6. Id
PID (Process ID)
프로세스를 구분하는 고유 번호
예: AggregatorHost → PID 9652
aihost → PID 4552

📌 7. SI
Session ID (세션 ID)
1 → 사용자 세션
0 → 서비스 세션 (SYSTEM 계정)
즉:
SI = 0 → 시스템 서비스
SI = 1 → 사용자가 실행한 프로세스

📌 8. ProcessName
프로세스 실행 파일 이름
예: AggregatorHost, aihost, AIXHost 등

📌 전체 의미 요약
각 줄은 "프로세스 하나"를 의미하며,
해당 프로세스가: 얼마나 많은 OS 자원을 잡고 있는지(Handles, Memory)
CPU를 얼마나 사용했는지
어떤 세션에서 실행되는지
PID는 무엇인지
이 정보를 보여주는 리스트다.



#포그라운드와 백그라운드(fg, bg, jobs)
-fg는 정지된 프로세스나 백그라운드 프로세스를 포그라운드로 가져옵니다. 
-bg는 정지된 프로세스를 백그라운드에서 실행하도록 합니다. 
-&는 프로세스를 백그라운드에서 실행하겠다는 뜻
-백그라운드에서 실행한 후 jobs로 동작중인 프로세스를 확인합니다.


프로세스 종료(kill, pkill)
프로세스 우선 순위(nice)
프로세스 모니터링(htop)


